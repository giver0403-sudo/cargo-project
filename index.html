<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ìŠ¤ë§ˆíŠ¸ ë°°ì°¨ Pro - ì‹¤ì‹œê°„ ë°ì´í„° ì—°ë™</title>
    <style>
        body { margin: 0; display: flex; font-family: 'Pretendard', sans-serif; background: #ffffff; height: 100vh; overflow: hidden; }
        #sidebar { width: 340px; background: #2c3e50; color: white; padding: 25px; box-sizing: border-box; overflow-y: auto; border-right: 2px solid #1a252f; }
        #canvas-container { flex: 1; position: relative; background: #f8f9fa; }
        .control-group { margin-bottom: 20px; background: #34495e; padding: 18px; border-radius: 12px; }
        h2 { font-size: 20px; margin-top: 0; color: #2ecc71; border-bottom: 1px solid #555; padding-bottom: 10px; }
        label { display: block; margin-bottom: 8px; font-size: 13px; color: #bdc3c7; font-weight: 500; }
        select { width: 100%; padding: 12px; border-radius: 6px; border: none; margin-bottom: 15px; font-size: 14px; background: #ffffff; color: #2c3e50; font-weight: bold; cursor: pointer; }
        .summary-card { background: #1a252f; padding: 15px; border-radius: 8px; border-left: 5px solid #f1c40f; line-height: 1.6; font-size: 13px; color: #ecf0f1; }
        .v-label { position: absolute; background: rgba(44, 62, 80, 0.95); color: white; padding: 5px 12px; border-radius: 4px; font-size: 11px; pointer-events: none; border: 1px solid #f1c40f; white-space: nowrap; font-weight: bold; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>ğŸšš ìŠ¤ë§ˆíŠ¸ ë°°ì°¨ Pro</h2>
    
    <div class="control-group">
        <label>ğŸš› 1. íˆ¬ì… ì°¨ëŸ‰ ì„ íƒ (ì‹¤ì‹œê°„ ì‹œíŠ¸)</label>
        <select id="vehicleSelect" onchange="runSimulation()">
            <option value="">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</option>
        </select>

        <label>ğŸ“¦ 2. ì ì¬ ë°©ë²• (ë‹¨ìˆ˜ ì œí•œ)</label>
        <select id="stackLimit" onchange="runSimulation()">
            <option value="1">1ë‹¨ ì ì¬ (ë°”ë‹¥ë§Œ ì±„ìš°ê¸°)</option>
            <option value="2">2ë‹¨ ì ì¬ (ìµœëŒ€ 2ì¸µ ìŒ“ê¸°)</option>
            <option value="99" selected>ì œí•œ ì—†ìŒ (ë†’ì´ ëê¹Œì§€)</option>
        </select>
    </div>

    <div id="report" class="summary-card">ì‹œíŠ¸ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>
</div>

<div id="canvas-container">
    <div id="label-container"></div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ì œê³µí•´ì£¼ì‹  ì‹¤ì œ CSV ë§í¬ ì ìš©
    const V_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3TqnJSKLXQldW8eyG85KpubspA4k9MZCsDuxnhyKNNpBTs0QCoRfM73j4CvA9-pGrSx0mq25ga42F/pub?gid=0&single=true&output=csv';
    const C_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3TqnJSKLXQldW8eyG85KpubspA4k9MZCsDuxnhyKNNpBTs0QCoRfM73j4CvA9-pGrSx0mq25ga42F/pub?gid=1155672676&single=true&output=csv';

    let scene, camera, renderer, controls, vehicles = [], cargoList = [], labels = [];
    const GAP = 1; // 1cm ì—¬ìœ 

    async function init() {
        scene = new THREE.Scene(); scene.background = new THREE.Color(0xf1f3f5);
        camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 340) / window.innerHeight, 1, 1000000);
        camera.position.set(2000, 1500, 2000); 
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 340, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.4); light.position.set(1,2,1); scene.add(light);
        
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500000, 500000), new THREE.MeshPhongMaterial({ color: 0xdee2e6 }));
        floor.rotation.x = -Math.PI / 2; scene.add(floor);
        
        await loadData();
        runSimulation();
        animate();
    }

    async function loadData() {
        try {
            const [vText, cText] = await Promise.all([
                fetch(V_URL).then(r => r.text()),
                fetch(C_URL).then(r => r.text())
            ]);
            vehicles = parseCSV(vText, 'v');
            cargoList = parseCSV(cText, 'c');
            
            const vSelect = document.getElementById('vehicleSelect');
            vSelect.innerHTML = vehicles.map((v, i) => 
                `<option value="${i}">${v.type} (${v.l}x${v.w}x${v.h} cm)</option>`
            ).join('');
        } catch (e) { document.getElementById('report').innerText = "ë°ì´í„° ë¡œë”© ì˜¤ë¥˜! ì‹œíŠ¸ 'ì›¹ì— ê²Œì‹œ' ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”."; }
    }

    function parseCSV(text, type) {
        return text.split('\n').slice(1).map(row => {
            const cols = row.split(',').map(s => s.trim().replace(/"/g, ''));
            if(cols.length < 4) return null;
            if(type === 'v') return { type: cols[0], l: parseFloat(cols[1]), w: parseFloat(cols[2]), h: parseFloat(cols[3]) };
            return { id: cols[0], l: parseFloat(cols[1]), w: parseFloat(cols[2]), h: parseFloat(cols[3]), qty: parseInt(cols[4]), color: cols[6] || '#3498db' };
        }).filter(item => item && !isNaN(item.l));
    }

    window.runSimulation = function() {
        if (!vehicles.length || !cargoList.length) return;
        
        const selectedVIdx = document.getElementById('vehicleSelect').value;
        const v = vehicles[selectedVIdx];
        const stackLimit = parseInt(document.getElementById('stackLimit').value);
        
        labels.forEach(l => l.el.remove()); labels = [];
        const toRemove = [];
        scene.traverse(child => { if(child instanceof THREE.Group) toRemove.push(child); });
        toRemove.forEach(group => scene.remove(group));

        let pending = [];
        cargoList.forEach(c => { for(let i=0; i<c.qty; i++) pending.push({...c}); });
        pending.sort((a,b) => (b.l * b.w) - (a.l * a.w)); 

        let vCounter = 0, offsetX = 0, results = [];

        while(pending.length > 0) {
            const group = new THREE.Group();
            let stillPending = [];
            let occupied = []; 

            pending.forEach(item => {
                let placed = false;
                // Y(ë†’ì´) -> Z(ê¸¸ì´) -> X(í­) ìˆœì„œë¡œ ì ì¬ ê³µê°„ íƒìƒ‰
                for (let y = 0; y <= v.h - item.h; y += 2) {
                    for (let z = -v.l/2 + GAP; z <= v.l/2 - item.l - GAP; z += 5) {
                        for (let x = -v.w/2 + GAP; x <= v.w/2 - item.w - GAP; x += 5) {
                            let layers = 0;
                            if(y>0) occupied.forEach(p => { 
                                if(!((x+item.w+GAP)<=p.x||x>=(p.x+p.w+GAP)||(z+item.l+GAP)<=p.z||z>=(p.z+p.l+GAP)) && p.y < y) layers++; 
                            });
                            if ((layers + 1) > stackLimit) continue;
                            
                            let coll = false;
                            for (let p of occupied) { 
                                if (!(x+item.w+GAP<=p.x||x>=p.x+p.w+GAP||y+item.h+GAP<=p.y||y>=p.y+p.h+GAP||z+item.l+GAP<=p.z||z>=(p.z+p.l+GAP))) { coll = true; break; } 
                            }
                            
                            if (!coll) {
                                const geo = new THREE.BoxGeometry(item.w, item.h, item.l).translate(0, item.h/2, 0);
                                const mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({color: item.color, transparent:true, opacity:0.85}));
                                mesh.position.set(x + item.w/2, y, z + item.l/2);
                                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({color: 0x000000, opacity: 0.2, transparent: true})));
                                group.add(mesh);
                                occupied.push({x, y, z, w: item.w, h: item.h, l: item.l});
                                placed = true; break;
                            }
                        }
                        if (placed) break;
                    }
                    if (placed) break;
                }
                if (!placed) stillPending.push(item);
            });

            const truckGeo = new THREE.BoxGeometry(v.w, v.h, v.l).translate(0, v.h/2, 0);
            group.add(new THREE.BoxHelper(new THREE.Mesh(truckGeo), 0x2c3e50));
            group.position.x = offsetX;
            scene.add(group);

            results.push(`<b>${vCounter+1}í˜¸ì°¨</b>: ${pending.length - stillPending.length}ê°œ ì ì¬`);
            const el = document.createElement('div'); el.className = 'v-label';
            el.innerText = `${vCounter+1}í˜¸ì°¨ (${v.type})`; document.getElementById('label-container').appendChild(el);
            labels.push({ el, pos: new THREE.Vector3(offsetX, v.h + 80, 0) });

            pending = stillPending;
            offsetX += v.w + 500; 
            vCounter++;
            if(vCounter > 30) break; 
        }
        document.getElementById('report').innerHTML = "<b>[ì‹œë®¬ë ˆì´ì…˜ ìš”ì•½]</b><br>" + results.join('<br>');
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update(); 
        labels.forEach(l => {
            const vector = l.pos.clone().project(camera);
            l.el.style.left = (vector.x + 1) * (window.innerWidth - 340) / 2 + 'px';
            l.el.style.top = -(vector.y - 1) * window.innerHeight / 2 + 'px';
            l.el.style.display = vector.z < 1 ? 'block' : 'none';
        });
        renderer.render(scene, camera); 
    }
    init();
</script>
</body>
</html>