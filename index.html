<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ìŠ¤ë§ˆíŠ¸ ë°°ì°¨ Pro - ì°¨ëŸ‰ ë¶„í•  ì ì¬ ìˆ˜ì •íŒ</title>
    <style>
        body { margin: 0; display: flex; font-family: 'Pretendard', sans-serif; background: #ffffff; height: 100vh; overflow: hidden; }
        #sidebar { width: 320px; background: #2c3e50; color: white; padding: 25px; box-sizing: border-box; overflow-y: auto; }
        #canvas-container { flex: 1; position: relative; }
        .control-group { margin-bottom: 20px; background: #34495e; padding: 15px; border-radius: 8px; border-left: 5px solid #2ecc71; }
        label { display: block; margin-bottom: 10px; font-size: 14px; font-weight: bold; }
        select { width: 100%; padding: 12px; border-radius: 5px; border: none; margin-bottom: 15px; font-size: 14px; background: #ecf0f1; cursor: pointer; color: #2c3e50; font-weight: bold; }
        .summary-card { background: #34495e; padding: 15px; border-radius: 10px; border-left: 5px solid #f1c40f; line-height: 1.6; font-size: 13px; }
        .v-label { position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 6px 12px; border-radius: 20px; font-size: 11px; pointer-events: none; transform: translate(-50%, -100%); border: 1px solid #f1c40f; white-space: nowrap; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>ğŸšš ìŠ¤ë§ˆíŠ¸ ë°°ì°¨ Pro</h2>
    <div class="control-group">
        <label>ğŸ“¦ ì ì¬ ë‹¨ìˆ˜(Layer) ì„ íƒ</label>
        <select id="stackLimit" onchange="runSimulation()">
            <option value="1">1ë‹¨ ì ì¬ (ë°”ë‹¥ ì „ìš©)</option>
            <option value="2">2ë‹¨ ì ì¬ (ìµœëŒ€ 2ì¸µ)</option>
            <option value="3" selected>3ë‹¨ ì ì¬ (ìµœëŒ€ 3ì¸µ)</option>
            <option value="99">ì œí•œ ì—†ìŒ</option>
        </select>
    </div>
    <div id="report" class="summary-card">ì˜µì…˜ì— ë”°ë¼ ì°¨ëŸ‰ì´ ìë™ ë¶„í• ë©ë‹ˆë‹¤.</div>
</div>
<div id="canvas-container"><div id="label-container"></div></div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const V_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3TqnJSKLXQldW8eyG85KpubspA4k9MZCsDuxnhyKNNpBTs0QCoRfM73j4CvA9-pGrSx0mq25ga42F/pub?gid=0&single=true&output=csv';
    const C_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3TqnJSKLXQldW8eyG85KpubspA4k9MZCsDuxnhyKNNpBTs0QCoRfM73j4CvA9-pGrSx0mq25ga42F/pub?gid=1155672676&single=true&output=csv';

    let scene, camera, renderer, controls, vehicles = [], cargoList = [], labels = [];
    const GAP = 10; 

    async function init() {
        scene = new THREE.Scene(); scene.background = new THREE.Color(0xffffff);
        camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 320) / window.innerHeight, 1, 10000000);
        camera.position.set(60000, 45000, 60000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 320, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000000, 5000000), new THREE.MeshPhongMaterial({ color: 0xeeeeee }));
        floor.rotation.x = -Math.PI / 2; scene.add(floor);
        await loadData();
        runSimulation();
        animate();
    }

    async function loadData() {
        const [vRes, cRes] = await Promise.all([fetch(V_URL), fetch(C_URL)]);
        vehicles = parseCSV(await vRes.text(), 'v');
        cargoList = parseCSV(await cRes.text(), 'c');
    }

    function parseCSV(text, type) {
        return text.split('\n').slice(1).map(row => {
            const cols = row.split(',').map(s => s.trim().replace(/"/g, ''));
            if(type === 'v') return { type: cols[0], l: parseFloat(cols[1]), w: parseFloat(cols[2]), h: parseFloat(cols[3]) };
            return { id: cols[0], l: parseFloat(cols[1]), w: parseFloat(cols[2]), h: parseFloat(cols[3]), qty: parseInt(cols[4]), color: cols[6] || '#3498db' };
        }).filter(item => item && item.l > 0);
    }

    // ì°¨ëŸ‰ ì„ íƒ í•µì‹¬ ë¡œì§ (ìŠ¹ê¸‰ ì‹œìŠ¤í…œ ì ìš©)
    function findBestVehicle(pendingCargo, sortedV, stackLimit) {
        // ì‘ì€ ì°¨ë¶€í„° íƒìƒ‰í•˜ë©° "ëª¨ë‘ ë‹¤ ì‹¤ë¦¬ëŠ” ì°¨"ê°€ ìˆìœ¼ë©´ ì„ íƒ
        for (let v of sortedV) {
            if (checkAllFit(v, pendingCargo, stackLimit)) return v;
        }
        // ë‹¤ ì‹¤ë¦¬ëŠ” ì°¨ê°€ ì—†ìœ¼ë©´ ê°€ì¥ í° ì°¨(40ft)ë¥¼ ë°˜í™˜í•˜ì—¬ ë¶„í•  ì ì¬ ì‹œì‘
        return sortedV[sortedV.length - 1];
    }

    function checkAllFit(vehicle, items, limit) {
        let occupied = [];
        let fitCount = 0;
        for (let item of items) {
            let placed = false;
            for (let z = -vehicle.l/2+GAP; z <= vehicle.l/2-item.l-GAP; z += 300) {
                for (let x = -vehicle.w/2+GAP; x <= vehicle.w/2-item.w-GAP; x += 300) {
                    for (let y = 0; y <= vehicle.h-item.h; y += 300) {
                        let layers = 0;
                        if(y>0) occupied.forEach(p=>{if(!((x+item.w+GAP)<=p.x||x>=(p.x+p.w+GAP)||(z+item.l+GAP)<=p.z||z>=(p.z+p.l+GAP))&&p.y<y) layers++;});
                        if(layers+1 > limit) continue;
                        let coll = false;
                        for(let p of occupied){if(!(x+item.w+GAP<=p.x||x>=p.x+p.w+GAP||y+item.h+GAP<=p.y||y>=p.y+p.h+GAP||z+item.l+GAP<=p.z||z>=p.z+p.l+GAP)){coll=true;break;}}
                        if(!coll){occupied.push({x,y,z,w:item.w,h:item.h,l:item.l});placed=true;fitCount++;break;}
                    }
                    if(placed) break;
                }
                if(placed) break;
            }
        }
        return fitCount === items.length;
    }

    window.runSimulation = function() {
        if (!vehicles.length) return;
        const stackLimit = parseInt(document.getElementById('stackLimit').value);
        labels.forEach(l => l.el.remove()); labels = [];
        const toRemove = [];
        scene.traverse(child => { if(child instanceof THREE.Group) toRemove.push(child); });
        toRemove.forEach(group => scene.remove(group));

        let pending = [];
        cargoList.forEach(c => { for(let i=0; i<c.qty; i++) pending.push({...c}); });
        pending.sort((a,b) => (b.l * b.w * b.h) - (a.l * a.w * a.h)); 

        let sortedV = [...vehicles].sort((a,b) => (a.l * a.w * a.h) - (b.l * b.w * b.h)); 
        let vIdx = 0, offsetX = 0, results = [];

        while(pending.length > 0) {
            // [ìˆ˜ì •] í˜„ì¬ ë‚¨ì€ ì§ì— ëŒ€í•´ ê°€ì¥ ì ì ˆí•œ ì°¨ëŸ‰ì„ ê³ ë¦„
            let v = findBestVehicle(pending, sortedV, stackLimit);
            
            const group = new THREE.Group();
            let stillPending = [];
            let occupied = []; 

            pending.forEach(item => {
                let placed = false;
                // ì „ë°© ë°€ì°© ì ì¬ (Z -> X -> Y ìˆœì„œ)
                for (let y = 0; y <= v.h - item.h; y += 150) {
                    for (let z = -v.l/2 + GAP; z <= v.l/2 - item.l - GAP; z += 150) {
                        for (let x = -v.w/2 + GAP; x <= v.w/2 - item.w - GAP; x += 150) {
                            let layers = 0;
                            if(y>0) occupied.forEach(p => { if(!((x+item.w+GAP)<=p.x||x>=(p.x+p.w+GAP)||(z+item.l+GAP)<=p.z||z>=(p.z+p.l+GAP)) && p.y < y) layers++; });
                            if ((layers + 1) > stackLimit) continue;
                            let coll = false;
                            for (let p of occupied) { if (!(x+item.w+GAP<=p.x||x>=p.x+p.w+GAP||y+item.h+GAP<=p.y||y>=p.y+p.h+GAP||z+item.l+GAP<=p.z||z>=(p.z+p.l+GAP))) { coll = true; break; } }
                            if (!coll) {
                                const geo = new THREE.BoxGeometry(item.w, item.h, item.l).translate(0, item.h/2, 0);
                                const mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({color: item.color, transparent:true, opacity:0.85}));
                                mesh.position.set(x + item.w/2, y, z + item.l/2);
                                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({color: 0x000000})));
                                group.add(mesh);
                                occupied.push({x, y, z, w: item.w, h: item.h, l: item.l});
                                placed = true; break;
                            }
                        }
                        if (placed) break;
                    }
                    if (placed) break;
                }
                if (!placed) stillPending.push(item);
            });

            group.add(new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(v.w, v.h, v.l).translate(0, v.h/2, 0)), 0x2c3e50));
            group.position.x = offsetX; scene.add(group);
            results.push(`${vIdx+1}í˜¸ì°¨: ${v.type} (${pending.length-stillPending.length}ê°œ)`);
            const el = document.createElement('div'); el.className = 'v-label';
            el.innerText = `${vIdx+1}í˜¸ì°¨: ${v.type}`; document.getElementById('label-container').appendChild(el);
            labels.push({ el, pos: new THREE.Vector3(offsetX, v.h + 1500, 0) });
            
            pending = stillPending; offsetX += v.w + 12000; vIdx++;
            if(vIdx > 15) break;
        }
        document.getElementById('report').innerHTML = "<b>[ë°°ì°¨ ìš”ì•½]</b><br>" + results.join('<br>');
    }

    function animate() { requestAnimationFrame(animate); controls.update(); 
        labels.forEach(l => {
            const vector = l.pos.clone().project(camera);
            l.el.style.left = (vector.x + 1) * (window.innerWidth - 320) / 2 + 'px';
            l.el.style.top = -(vector.y - 1) * window.innerHeight / 2 + 'px';
            l.el.style.display = vector.z < 1 ? 'block' : 'none';
        });
        renderer.render(scene, camera); 
    }
    init();
</script>
</body>
</html>